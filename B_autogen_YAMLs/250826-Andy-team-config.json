{
  "provider": "autogen_agentchat.teams.SelectorGroupChat",
  "component_type": "team",
  "version": 1,
  "component_version": 1,
  "description": "Une équipe organisée pour produire des synthèses à partir du web\nCette équipe comporte trois agents :\n- le Chercheur, qui recherche sur le web des informations sur le thème indiqué, et analyse les informations recueillies\n- le Vérificateur, qui vérifie la qualité, la clarté et la complétude des informations recueillies\n- le Consolidateur, qui produit, en format markdown, une synthèse des résultats de la recherche et un rapport récapitulatif destiné à l'Utilisateur principal.",
  "label": "Andy produit des synthèses à partir du web",
  "config": {
    "participants": [
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "Un agent qui recherche sur le web des informations sur le thème indiqué, à l'aide de Tools.",
        "label": "Chercheur",
        "config": {
          "name": "Chercheur",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "OpenAI GPT-4o-mini",
            "label": "OpenAI gpt-4o-mini on LV",
            "config": {
              "model": "gpt-4o-mini",
              "api_key": "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",
              "organization": ""
            }
          },
          "tools": [
            {
              "provider": "autogen_core.tools.FunctionTool",
              "component_type": "tool",
              "version": 1,
              "component_version": 1,
              "description": "Create custom tools by wrapping standard Python functions.",
              "label": "FunctionTool",
              "config": {
                "source_code": "async def google_search(\n    query: str,\n    num_results: int = 3,\n    include_snippets: bool = True,\n    include_content: bool = True,\n    content_max_length: Optional[int] = 10000,\n    language: str = \"en\",\n    country: Optional[str] = None,\n    safe_search: bool = True,\n) -> List[Dict[str, str]]:\n    \"\"\"\n    Perform a Google search using the Custom Search API and optionally fetch webpage content.\n\n    Args:\n        query: Search query string\n        num_results: Number of results to return (max 10)\n        include_snippets: Include result snippets in output\n        include_content: Include full webpage content in markdown format\n        content_max_length: Maximum length of webpage content (if included)\n        language: Language code for search results (e.g., en, es, fr)\n        country: Optional country code for search results (e.g., us, uk)\n        safe_search: Enable safe search filtering\n\n    Returns:\n        List[Dict[str, str]]: List of search results, each containing:\n            - title: Result title\n            - link: Result URL\n            - snippet: Result description (if include_snippets=True)\n            - content: Webpage content in markdown (if include_content=True)\n    \"\"\"\n    api_key = os.getenv(\"GOOGLE_API_KEY\")\n    cse_id = os.getenv(\"GOOGLE_CSE_ID\")\n\n    if not api_key or not cse_id:\n        raise ValueError(\"Missing required environment variables. Please set GOOGLE_API_KEY and GOOGLE_CSE_ID.\")\n\n    num_results = min(max(1, num_results), 10)\n\n    async def fetch_page_content(url: str, max_length: Optional[int] = 50000) -> str:\n        \"\"\"Helper function to fetch and convert webpage content to markdown\"\"\"\n        headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"}\n\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.get(url, headers=headers, timeout=10)\n                response.raise_for_status()\n\n                soup = BeautifulSoup(response.text, \"html.parser\")\n\n                # Remove script and style elements\n                for script in soup([\"script\", \"style\"]):\n                    script.decompose()\n\n                # Convert relative URLs to absolute\n                for tag in soup.find_all([\"a\", \"img\"]):\n                    if tag.get(\"href\"):\n                        tag[\"href\"] = urljoin(url, tag[\"href\"])\n                    if tag.get(\"src\"):\n                        tag[\"src\"] = urljoin(url, tag[\"src\"])\n\n                h2t = html2text.HTML2Text()\n                h2t.body_width = 0\n                h2t.ignore_images = False\n                h2t.ignore_emphasis = False\n                h2t.ignore_links = False\n                h2t.ignore_tables = False\n\n                markdown = h2t.handle(str(soup))\n\n                if max_length and len(markdown) > max_length:\n                    markdown = markdown[:max_length] + \"\\n...(truncated)\"\n\n                return markdown.strip()\n\n        except Exception as e:\n            return f\"Error fetching content: {str(e)}\"\n\n    params = {\n        \"key\": api_key,\n        \"cx\": cse_id,\n        \"q\": query,\n        \"num\": num_results,\n        \"hl\": language,\n        \"safe\": \"active\" if safe_search else \"off\",\n    }\n\n    if country:\n        params[\"gl\"] = country\n\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\"https://www.googleapis.com/customsearch/v1\", params=params, timeout=10)\n            response.raise_for_status()\n            data = response.json()\n\n            results = []\n            if \"items\" in data:\n                for item in data[\"items\"]:\n                    result = {\"title\": item.get(\"title\", \"\"), \"link\": item.get(\"link\", \"\")}\n                    if include_snippets:\n                        result[\"snippet\"] = item.get(\"snippet\", \"\")\n\n                    if include_content:\n                        result[\"content\"] = await fetch_page_content(result[\"link\"], max_length=content_max_length)\n\n                    results.append(result)\n\n            return results\n\n    except httpx.RequestError as e:\n        raise ValueError(f\"Failed to perform search: {str(e)}\") from e\n    except KeyError as e:\n        raise ValueError(f\"Invalid API response format: {str(e)}\") from e\n    except Exception as e:\n        raise ValueError(f\"Error during search: {str(e)}\") from e\n",
                "name": "google_search",
                "description": "\n    Perform Google searches using the Custom Search API with optional webpage content fetching.\n    Requires GOOGLE_API_KEY and GOOGLE_CSE_ID environment variables to be set.\n    ",
                "global_imports": [
                  {
                    "module": "typing",
                    "imports": [
                      "List",
                      "Dict",
                      "Optional"
                    ]
                  },
                  "os",
                  "httpx",
                  "html2text",
                  {
                    "module": "bs4",
                    "imports": [
                      "BeautifulSoup"
                    ]
                  },
                  {
                    "module": "urllib.parse",
                    "imports": [
                      "urljoin"
                    ]
                  }
                ],
                "has_cancellation_support": false
              }
            },
            {
              "provider": "autogen_core.tools.FunctionTool",
              "component_type": "tool",
              "version": 1,
              "component_version": 1,
              "description": "Create custom tools by wrapping standard Python functions.",
              "label": "FunctionTool",
              "config": {
                "source_code": "async def fetch_webpage(\n    url: str, include_images: bool = True, max_length: Optional[int] = None, headers: Optional[Dict[str, str]] = None\n) -> str:\n    \"\"\"Fetch a webpage and convert it to markdown format.\n\n    Args:\n        url: The URL of the webpage to fetch\n        include_images: Whether to include image references in the markdown\n        max_length: Maximum length of the output markdown (if None, no limit)\n        headers: Optional HTTP headers for the request\n\n    Returns:\n        str: Markdown version of the webpage content\n\n    Raises:\n        ValueError: If the URL is invalid or the page can't be fetched\n    \"\"\"\n    # Use default headers if none provided\n    if headers is None:\n        headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"}\n\n    try:\n        # Fetch the webpage\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n\n            # Parse HTML\n            soup = BeautifulSoup(response.text, \"html.parser\")\n\n            # Remove script and style elements\n            for script in soup([\"script\", \"style\"]):\n                script.decompose()\n\n            # Convert relative URLs to absolute\n            for tag in soup.find_all([\"a\", \"img\"]):\n                if tag.get(\"href\"):\n                    tag[\"href\"] = urljoin(url, tag[\"href\"])\n                if tag.get(\"src\"):\n                    tag[\"src\"] = urljoin(url, tag[\"src\"])\n\n            # Configure HTML to Markdown converter\n            h2t = html2text.HTML2Text()\n            h2t.body_width = 0  # No line wrapping\n            h2t.ignore_images = not include_images\n            h2t.ignore_emphasis = False\n            h2t.ignore_links = False\n            h2t.ignore_tables = False\n\n            # Convert to markdown\n            markdown = h2t.handle(str(soup))\n\n            # Trim if max_length is specified\n            if max_length and len(markdown) > max_length:\n                markdown = markdown[:max_length] + \"\\n...(truncated)\"\n\n            return markdown.strip()\n\n    except httpx.RequestError as e:\n        raise ValueError(f\"Failed to fetch webpage: {str(e)}\") from e\n    except Exception as e:\n        raise ValueError(f\"Error processing webpage: {str(e)}\") from e\n",
                "name": "fetch_webpage",
                "description": "Fetch a webpage and convert it to markdown format, with options for including images and limiting length",
                "global_imports": [
                  "os",
                  "html2text",
                  {
                    "module": "typing",
                    "imports": [
                      "Optional",
                      "Dict"
                    ]
                  },
                  "httpx",
                  {
                    "module": "bs4",
                    "imports": [
                      "BeautifulSoup"
                    ]
                  },
                  {
                    "module": "html2text",
                    "imports": [
                      "HTML2Text"
                    ]
                  },
                  {
                    "module": "urllib.parse",
                    "imports": [
                      "urljoin"
                    ]
                  }
                ],
                "has_cancellation_support": false
              }
            }
          ],
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "A research assistant that performs web searches and analyzes information",
          "system_message": "Tu es un assistant de recherche chargé de trouver des informations exactes.\nUtilise le Tool google_search, et éventuellement tes autres Tools, pour trouver des informations pertinentes.\nDécompose les requêtes complexes en termes de recherche spécifiques.\nTu es un assistant de recherche chargé de trouver des informations exactes.\nUtilise le Tool google_search, et éventuellement tes autres Tools, pour trouver des informations pertinentes.\nDécompose les requêtes complexes en termes de recherche spécifiques.\nLorsque les sources d'info que tu trouves contiennent des informations qui répondent de manière pertinente à ta requête, rédige un rapport qui récapitule ces informations, lorsque c'est possible.\nLorsque la recherche est terminée, fournit un résumé détaillé en markdown. \nVérifie toujours les informations à travers plusieurs sources lorsque c’est possible.\nLorsque tu reçois un retour de l’agent Verificateur, tiens compte de ce retour et fais progresser la recherche, en utilisant tes tools si nécessaire\n",
          "model_client_stream": false,
          "reflect_on_tool_use": false,
          "tool_call_summary_format": "{result}"
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "Un agent qui procure un assistance, en vérifiant la justesse, la pertinence, la clarté, et la complétude des informations qu'on lui soumet",
        "label": "Verificateur",
        "config": {
          "name": "Verificateur",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "OpenAI GPT-4o-mini",
            "label": "OpenAI gpt-4o-mini on LV",
            "config": {
              "model": "gpt-4o-mini",
              "api_key": "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",
              "organization": ""
            }
          },
          "tools": [],
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "A verification specialist who ensures research quality and completeness",
          "system_message": "Tu es un spécialiste de la vérification des résultats de recherche.\nTon rôle est de :\n\n - Vérifier que les requêtes de recherche sont efficaces et suggérer des améliorations si nécessaire\n\n- Explorer plus en profondeur lorsque c’est utile, par exemple si la réponse se trouve probablement dans un lien parmi les résultats de recherche, suggérer de cliquer sur ce lien\n\n- Suggérer des angles ou des perspectives supplémentaires à explorer. Sois judicieux dans tes suggestions afin d’éviter l’élargissement excessif du périmètre ou le gaspillage de ressources. \n\n- Suivre les progrès réalisés vers la réponse à la question initiale\n\nPour une recherche incomplète, termine to message par \"CONTINUE RESEARCH\". Pour une recherche complète, termine ton message par \"APPROVED\"\n\nTes réponses doivent être structurées comme suit :\n\nÉvaluation des progrès\n\n - Lacunes/Problèmes (le cas échéant)\n- Suggestions (si nécessaire)\n- Prochaines étapes ou Résumé final",
          "model_client_stream": false,
          "reflect_on_tool_use": false,
          "tool_call_summary_format": "{result}"
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "Un agent qui consolide et produit des synthèses, à l'aide d'outils",
        "label": "Consolidateur",
        "config": {
          "name": "Consolidateur",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "OpenAI GPT-4o-mini",
            "label": "OpenAI gpt-4o-mini on LV",
            "config": {
              "model": "gpt-4o-mini",
              "api_key": "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",
              "organization": ""
            }
          },
          "tools": [],
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "A summary agent that provides a detailed markdown summary of the research as a report to the user.",
          "system_message": "Tu es un agent spécialisé dns la synthèse d'informations et la production de rapports.\nTon rôle est de fournir à l’utilisateur un résumé détaillé de la recherche sous forme de rapport en markdown.\nTon rapport doit comporter un titre pertinent correspondant à la question de recherche et résumer les éléments clés des résultats trouvés de manière naturelle et exploitable.\n\nLe résultat principal / la réponse principale doit apparaître dans le premier paragraphe.\n\nLorsque cela est pertinent, ton rapport doit inclure des tableaux comparatifs clairs permettant de dégager des enseignements critiques.\n\nIl est essentiel d’ajouter une section Références et de citer les sources principales (lorsqu’elles sont disponibles) pour les faits mentionnés dans le corps du rapport.\n\nLorsque c’est approprié, tu peux ajouter des images (si disponibles) illustrant les concepts nécessaires au résumé.\n\nTon rapport doit se terminer par le mot \"TERMINATE\" afin de signaler la fin de la conversation.",
          "model_client_stream": false,
          "reflect_on_tool_use": false,
          "tool_call_summary_format": "{result}"
        }
      }
    ],
    "model_client": {
      "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
      "component_type": "model",
      "version": 1,
      "component_version": 1,
      "description": "OpenAI GPT-4o-mini",
      "label": "OpenAI gpt-4o-mini on LV",
      "config": {
        "model": "gpt-4o-mini",
        "api_key": "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",
        "organization": ""
      }
    },
    "termination_condition": {
      "provider": "autogen_agentchat.base.OrTerminationCondition",
      "component_type": "termination",
      "version": 1,
      "component_version": 1,
      "label": "OrTerminationCondition",
      "config": {
        "conditions": [
          {
            "provider": "autogen_agentchat.conditions.TextMentionTermination",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "description": "Terminate the conversation if a specific text is mentioned.",
            "label": "TextMentionTermination",
            "config": {
              "text": "TERMINATE"
            }
          },
          {
            "provider": "autogen_agentchat.conditions.MaxMessageTermination",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "description": "Terminate the conversation after a maximum number of messages have been exchanged.",
            "label": "MaxMessageTermination",
            "config": {
              "max_messages": 30,
              "include_agent_event": false
            }
          }
        ]
      }
    },
    "selector_prompt": "Tu coordonnes une équipe de recherche en sélectionnant le membre de l’équipe qui doit parler ou agir ensuite. Les rôles suivants sont disponibles :\n{roles}.\n - Le Chercheur effectue des recherches et analyse les informations.\n- Le Vérificateur  évalue les progrès et s’assure de l’exhaustivité. Lorsqu'il estime que la recherche est complète, son message se termine par \"APPROVED\", sinon son message se termine par \"CONTINUE RESEARCH\"\n - Le Consolidateur fournit un résumé détaillé sous forme de rapport en markdown à destination de l’utilisateur.\n\nCompte tenu du contexte actuel, sélectionne le prochain intervenant le plus approprié.\nLe Chercheur doit rechercher et analyser.\nLe Vérificateur doit évaluer les progrès et orienter la recherche (sélectionne ce rôle s’il est nécessaire de vérifier/évaluer les progrès). \nTu ne dois sélectionner le rôle Consolidateur que si la recherche est terminée et qu’il est temps de générer un rapport.\n\nBase ta sélection sur :\n - L’étape actuelle de la recherche\n - Les conclusions ou suggestions du dernier intervenant\n- Le besoin de vérification vs le besoin de nouvelles informations\n\nLis la conversation suivante. Puis sélectionne le prochain rôle à jouer parmi {participants}. Ne retournez que le rôle.\n\n{history}\n\nRelis la conversation ci-dessus. Puis sélectionnez le prochain rôle à jouer parmi {participants}. NE RETOURNEZ QUE LE RÔLE.",
    "allow_repeated_speaker": true,
    "max_selector_attempts": 3
  }
}